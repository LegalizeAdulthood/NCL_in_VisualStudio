/*********************************************************************
**
**    NAME         :  d1cmdif.c
**
**       CONTAINS:
**				ud_cmdif()
**
**    COPYRIGHT 1984 (c) UNICAD Inc.  All Rights Reserved.
**
**    MODULE NAME AND RELEASE LEVEL 
**       d1cmdif.c , 25.1
**    DATE AND TIME OF LAST  MODIFICATION 
**       04/29/15 , 15:05:02
**
*********************************************************************/

#include "usysdef.h"
#include "zsysdep.h"
#include "ustdio.h"
#include "dwindow.h"
#include "dasnog.h"
#include "uims.h"
#include "uhep.h"
#include "udebug.h"
/* include semantic machine generated by tlangtool from d1cmd.gm */
#include "d1cmdsem.h"
#include "gcolors.h"

#ifdef UU_SINGLE
static char uu_sccsident[]={"@(#) d1cmdif.c 3.3 4/12/88 18:07:08 single"};
#else
static char uu_sccsident[]={"@(#) d1cmdif.c 3.3 4/12/88 18:07:08 double"};
#endif

static int *lexicon;	/* will get toolmalloc'd big enough to hold the lexicon */
static int symbol[10]={' ','<','s','>'};		/* name of distinguished symbol 
																starting in symbol[1] */
static int symlen=3;				/* length of symbol */
static int trace;				/* 1=tracing on, 0=no tracing */
static int  cfnindex;
static int  cendflag[21];
static int  cendindex = 0;

int  cmd2flag=UU_FALSE; /* flag for second calc call */
int  cmd2rslt;				/* flag to check whether calc2 gets result */
int  cmdlxconflag=UU_FALSE;	/* flag to detect whether lexicon has been read */
float  cmddval[4];
int  cmddebug;
int  cmder1;				/* error flag for undefined symbol */
int  cmder2;				/* error flag for common errors    */
int  cmdfuncflag;			/* flag to show the function parsing is on */
int  cmdinptr;				/* pointer to next symbol in the "in"  */
int  cmdstkpt;				/* stack pointer                   */
int  cmdfpar;				/* index for function name stack     */
UD_AREA *areapt;
Gdrect winbnd;				/* window bounds */

int *udi_dlxconread();

#define INC (UU_REAL) .05			/* increment to adjust windows by */

/*********************************************************************
**    E_FUNCTION :  ud_cmdif()
**				Main subroutine of the command language interface. Call
**				langtool and the input routine to start parsing the input line 
**				until user input a command of 'QUIT' to quit the cmdinput.
**
**    PARAMETERS   
**       INPUT  : 
**          none
**       OUTPUT :  
**          none
**
**    RETURNS      : none
**    SIDE EFFECTS : none
**    WARNINGS     : none
*********************************************************************/

ud_cmdif()
{
	static int one=1;		/* static ok since never change value */
	int markval;
	int stack[1000];		/* stack area for parser to use */
	int its[1000];			/* parser returns translation sequence here*/
	int ltr;					/* length of returned translation sequence */
	int irc;					/* return code from lxread or parser */
	int in[200];			/* user input buffer */
	int len;					/* length of fname or input buffer */
	int irkf;				/* in[irkf-1] contains index of last
									matched character position of parse */
	int bckgrnd;
	UD_WINDOW_REC wcb;	/* window control block */
	int args[2];

	uu_denter(UU_DTRC,(us,"ud_cmdif() cendindex=%d",cendindex));
   if (cmdlxconflag == UU_FALSE) {
		lexicon=udi_dlxconread(&irc,"M_CMDGRAM");
		cmddebug=0; trace=0;
		cmdlxconflag=UU_TRUE;
	}
	if (cendindex < 20)
	{

/*	-- create and bump windows -- */

	areapt = UD_duimsdeflt.screen[UD_curlayout.curr_screen].areas[UD_HLP];
	ud_devrect(&((*areapt).posn), &winbnd);
	bckgrnd = dqwinback();
/*	WINDOW_INIT(&wcb, &winbnd, UG_C_WHITE, bckgrnd);
/*	WINDOW_ON(&wcb, &UD_winrow, &UD_wincol);*/
	args[1] = 1;
	UD_winrow = 20; UD_wincol = 80;
	ul_open_window(UD_winrow,UD_wincol,args);
	cendflag[++cendindex] = 0;

	while (cendflag[cendindex]==0) 
	{	
		/* keep parsing as long as successful */
		/* read a symbol sequence from the user to be parsed */
			uti_tread(in,1,&len,&cendindex);		/* read the user's input line */
		uu_dprint(UU_DTRC,(us,
			"ud_cmdif uti_tread returned cendflag[%d]=%d len=%d in=%d %d %d",
			cendindex,cendflag[cendindex],len,in[1],in[2],in[3]));
		irc=0;
		cmder1 = UU_FALSE;   
		cmder2 = UU_FALSE;
		cmdfuncflag = UU_FALSE;
		cfnindex = 0;
		cmdstkpt = -1;
		cmdinptr = 1;			/* pointer to next symbol in the "in"  */
		cmdfpar = -1;

				 /* call the langpak parser routine to parse input */
		uu_dprint(UU_DTRC,(us,"ud_cmdif calling uti_parser"));
		uti_parser(symbol,symlen,in,one,len,lexicon,stack,&trace,
				&irkf,its,&ltr,&irc,semmch,NULL,NULL);
		uu_dprint(UU_DTRC,(us,"ud_cmdif uti_parser returned %d",irc));
		/* irc=0 if parse successful, else see page 128 of langpak book*/
		if (irc == 1) {
			if (cmder1)
				/* gmessage (D_ksws, " error - undefined name "); */
				uu_uerror0 (UQ_CALCERROR, 1);
			else
			   /* gmessage (D_ksws, " error - syntax error!! "); */
				uu_uerror0 (UQ_CALCERROR, 2);
			/*resetstack ();*/
        }	
	}			/* while */
	cendindex--;

/*	-- kill the window and adjust to next location -- */

/*	WINDOW_OFF(&wcb);*/
	ul_close_window();
	}	/* if    */
	else
		/*gmessage (D_ksws, " error - too many ud_cmdif calls, action denied"); */
		uu_uerror0 (UQ_CALCERROR, 3);
	uu_dexit;
}		/* ud_cmdif */

/*********************************************************************
**    E_FUNCTION:  cmdsetend()
**			set the endflag to quit the cmdinput
**
**    PARAMETERS   
**       INPUT  : 
**          none
**       OUTPUT :  
**          none
**
**    RETURNS      : none
**    SIDE EFFECTS : none
**    WARNINGS     : none
*********************************************************************/

cmdsetend()
{
	uu_denter(UU_DTRC,(us,"cmdsetend called"));
	if (cmd2flag == UU_FALSE)
			cendflag[cendindex] = 1;
	uu_dexit;
}		/* setend */
